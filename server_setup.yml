- name: Generate and sign server certificates with Cockpit compatibility
  hosts: servers  # Targets all servers in the inventory
  become: yes
  collections:
    - community.crypto
  vars:
    ca_server: "{{ ansible_host }}"  # CA server is the control node
    ca_server_ip: "192.168.50.176"  # IP address of CA server (control node)
    #key_path: /etc/pki/tls/private/server.key
    #cert_path: /etc/pki/tls/certs/server.crt
    #csr_path: /etc/pki/tls/csrs/server-csr.pem
    cockpit_cert_dir: /etc/cockpit/ws-certs.d
    tmp_dir: /var/tmp  # Temporary directory on target servers
    ca_tmp_dir: /var/tmp  # Temporary directory on CA server (control node)
  tasks:
    - name: Include Fedora variables
      include_vars:
        file: vars/fedora.yml
      when: ansible_distribution == "Fedora"

    - name: Include Debian variables
      include_vars:
        file: vars/debian.yml
      when: ansible_os_family == "Debian"

    - name: Include Home Assistant variable
      include_vars:
        file: vars/haos.yml
      when: ansible_distribution == "Alpine"
  
    - name: Ensure OpenSSL and cryptography packages are installed
      package:
        name:
          - openssl
          - "{{ 'py3-cryptography' if ansible_os_family == 'Alpine' else 'python3-cryptography' }}"
        state: present
      become: yes
      # Installs required packages on each target server
  
    - name: Ensure /etc/pki/tls and subdirectories exist
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: root
        group: root
      loop:
        - "{{tls_path}}"
        - "{{key_path}}"
        - "{{cert_path}}"
        - "{{csr_path}}"
      # Creates required directories on each target server

    - name: Ensure /var/tmp is writable on target server
      file:
        path: "{{ tmp_dir }}"
        state: directory
        mode: '1777'  # Sticky bit, world-writable
      # Ensures /var/tmp is accessible on target servers

    - name: Debug Ansible user
      ansible.builtin.debug:
        msg: "Ansible user is {{ ansible_user | default(ansible_user_id) }}"
      delegate_to: localhost

    - name: Ensure /var/tmp is writable on CA server (control node)
      file:
        path: "{{ ca_tmp_dir }}"
        state: directory
        mode: '1777'  # Sticky bit, world-writable
      delegate_to: localhost
      # Ensures /var/tmp is accessible on control node

    - name: Generate private key for server
      openssl_privatekey:
        path: "{{ key_path }}/server.key"
        size: 2048
        mode: '0400'
        owner: root
        group: root
        state: present
      # Generates private key on each target server
      
    - name: Debug additional hostnames
      debug:
        msg: "Additional hostnames: {{ additional_hostnames | default([]) }}"

- name: Generate CSR for server
  openssl_csr:
    path: "{{ csr_path }}/server-csr.pem"
    privatekey_path: "{{ key_path }}/server.key"
    common_name: "{{ inventory_hostname }}"
    subject:
      C: US
      ST: California
      L: SantaBarbara
      O: Home LAN
    subject_alt_name: "{{ san_list }}"
    key_usage:
      - digitalSignature
      - keyEncipherment
    extended_key_usage:
      - serverAuth
    mode: '0600'
    owner: root
    group: root
    state: present
  vars:
    san_list: "{{ [ 'DNS:' + inventory_hostname, 'DNS:' + inventory_hostname + '.home.arpa', 'IP:' + ansible_host ] + (additional_hostnames | default([]) | map('regex_replace', '^(.*)$', 'DNS:\\1') | list) }}"



    - name: Remove existing CSR on control node
      file:
        path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        state: absent
      delegate_to: localhost
      # Ensures no existing CSR file on control node

    - name: Fetch CSR to control node
      fetch:
        src: "{{ csr_path }}/server-csr.pem"
        dest: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        flat: yes
      # Fetches CSR from target server to control node

    - name: Sign CSR with CA on control node
      x509_certificate:
        path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
        csr_path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        ownca_privatekey_path: /etc/pki/lan-ca/private/ca-key.pem
        ownca_path: /etc/pki/lan-ca/certs/ca-cert.pem
        provider: ownca
        ownca_not_after: "+90d"  # Shorter validity for better security
        ownca_digest: sha256
        key_usage:
          - digitalSignature
          - keyEncipherment
        extended_key_usage:
          - serverAuth
        authority_information_access:
          - caIssuers: "http://ca.home.arpa/certs/ca-cert.pem"
        mode: '0644'
        owner: root
        group: root
        state: present
      delegate_to: localhost
      become: yes

    - name: Remove existing certificate on target server
      file:
        path: "{{ cert_path }}/server.crt"
        state: absent
      # Ensures no existing certificate on target server

    - name: Copy signed certificate to target server
      copy:
        src: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
        dest: "{{ cert_path }}/server.crt"
        mode: '0644'
        owner: root
        group: root
      # Copies signed certificate to target server

    - name: Clean up CSR and certificate on control node
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        - "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
      delegate_to: localhost
      # Cleans up temporary files on control node

    - name: Check certificate expiry
      command: openssl x509 -in "{{ cert_path }}/server.crt" -checkend 604800  # 7 days in seconds
      register: cert_expiry
      ignore_errors: yes
      changed_when: cert_expiry.rc != 0
      notify: Regenerate Certificate

    - name: Backup CA private key
      copy:
        src: /etc/pki/lan-ca/private/ca-key.pem
        dest: /etc/pki/lan-ca/private/ca-key-backup.pem
        mode: '0400'
        owner: root
        group: root
        remote_src: yes

    - name: Check if /etc/cockpit/ws-certs.d exists
      stat:
        path: "{{ cockpit_cert_dir }}"
      register: cockpit_dir
      # Checks if Cockpit certificate directory exists on target server

    - name: Create symbolic links for Cockpit if directory exists
      file:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        state: link
        owner: root
        group: root
        force: yes
      loop:
        - { src: "{{ key_path }}/server.key", dest: "{{ cockpit_cert_dir }}/server.key" }
        - { src: "{{ cert_path }}/server.crt", dest: "{{ cockpit_cert_dir }}/server.crt" }
      when: cockpit_dir.stat.exists
      notify: Restart Cockpit
      # Creates symlinks for Cockpit if directory exists

    - name: Check if Cockpit is installed
      stat:
        path: /usr/lib/systemd/system/cockpit.service
      register: cockpit_service
      # Checks if Cockpit is installed on target server

    - name: Set ownership and permissions for Cockpit service (if installed)
      file:
        path: "{{ item }}"
        owner: root
        group: root
        mode: "{{ '0400' if 'key' in item else '0644' }}"
      loop:
        - "{{ key_path }}/server.key"
        - "{{ cert_path }}/server.crt"
      when: cockpit_service.stat.exists
      notify: Restart Cockpit
      # Sets permissions for Cockpit if installed
  handlers:
    - name: Update CA Trust
      command: update-ca-trust
      when: ansible_distribution == "Fedora" or ansible_os_family == "RedHat"
  
    - name: Restart Cockpit
      service:
        name: cockpit
        state: restarted
      when: cockpit_service.stat.exists
