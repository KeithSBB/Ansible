- name: Generate and sign server certificates with Cockpit compatibility
  hosts: servers  # Targets all servers in the inventory
  become: yes
  collections:
    - community.crypto
  vars:
    ca_server: "{{ ansible_host }}"  # CA server is the control node
    ca_server_ip: "192.168.50.176"  # IP address of CA server (control node)
    key_path: /etc/pki/tls/private/server.key
    cert_path: /etc/pki/tls/certs/server.crt
    csr_path: /etc/pki/tls/csrs/server-csr.pem
    cockpit_cert_dir: /etc/cockpit/ws-certs.d
    tmp_dir: /var/tmp  # Temporary directory on target servers
    ca_tmp_dir: /var/tmp  # Temporary directory on CA server (control node)
  tasks:
    - name: Ensure OpenSSL and python3-cryptography are installed
      package:
        name:
          - openssl
          - python3-cryptography
        state: present
      # Installs required packages on each target server

    - name: Ensure /etc/pki/tls and subdirectories exist
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: root
        group: root
      loop:
        - /etc/pki/tls
        - /etc/pki/tls/private
        - /etc/pki/tls/certs
        - /etc/pki/tls/csrs
      # Creates required directories on each target server

    - name: Ensure /var/tmp is writable on target server
      file:
        path: "{{ tmp_dir }}"
        state: directory
        mode: '1777'  # Sticky bit, world-writable
      # Ensures /var/tmp is accessible on target servers

    - name: Debug Ansible user
      ansible.builtin.debug:
        msg: "Ansible user is {{ ansible_user | default(ansible_user_id) }}"
      delegate_to: localhost

    - name: Ensure /var/tmp is writable on CA server (control node)
      file:
        path: "{{ ca_tmp_dir }}"
        state: directory
        mode: '1777'  # Sticky bit, world-writable
      delegate_to: localhost
      # Ensures /var/tmp is accessible on control node

    - name: Generate private key for server
      openssl_privatekey:
        path: "{{ key_path }}"
        size: 2048
        mode: '0400'
        owner: root
        group: root
        state: present
      # Generates private key on each target server
      
    - name: Generate CSR for server
      openssl_csr:
        path: "{{ csr_path }}"
        privatekey_path: "{{ key_path }}"
        common_name: "{{ inventory_hostname }}"
        subject:
          C: US
          ST: California
          L: SantaBarbara
          O: Home LAN
        subject_alt_name: >-
          {{ ['DNS:' + inventory_hostname, 'DNS:' + inventory_hostname + '.home.arpa'] +
             (additional_hostnames | default([]) | map('regex_replace', '^(.*)$', 'DNS:\\1') | list) }}
        mode: '0600'
        owner: root
        group: root
        state: present
      # Generates CSR on each target server

    - name: Remove existing CSR on control node
      file:
        path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        state: absent
      delegate_to: localhost
      # Ensures no existing CSR file on control node

    - name: Fetch CSR to control node
      fetch:
        src: "{{ csr_path }}"
        dest: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        flat: yes
      # Fetches CSR from target server to control node

    - name: Sign CSR with CA on control node
      x509_certificate:
        path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
        csr_path: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        ownca_privatekey_path: /etc/pki/lan-ca/private/ca-key.pem
        ownca_path: /etc/pki/lan-ca/certs/ca-cert.pem
        provider: ownca
        ownca_not_after: "+365d"  # Certificate valid for 1 year
        ownca_digest: sha256
        mode: '0644'
        owner: root
        group: root
        state: present
      delegate_to: localhost
      become: yes
      # Signs CSR on control node (CA server)

    - name: Remove existing certificate on target server
      file:
        path: "{{ cert_path }}"
        state: absent
      # Ensures no existing certificate on target server

    - name: Copy signed certificate to target server
      copy:
        src: "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
        dest: "{{ cert_path }}"
        mode: '0644'
        owner: root
        group: root
      # Copies signed certificate to target server

    - name: Clean up CSR and certificate on control node
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.csr"
        - "{{ ca_tmp_dir }}/server-{{ inventory_hostname }}.crt"
      delegate_to: localhost
      # Cleans up temporary files on control node

    - name: Check if /etc/cockpit/ws-certs.d exists
      stat:
        path: "{{ cockpit_cert_dir }}"
      register: cockpit_dir
      # Checks if Cockpit certificate directory exists on target server

    - name: Create symbolic links for Cockpit if directory exists
      file:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        state: link
        owner: root
        group: root
        force: yes
      loop:
        - { src: "{{ key_path }}", dest: "{{ cockpit_cert_dir }}/server.key" }
        - { src: "{{ cert_path }}", dest: "{{ cockpit_cert_dir }}/server.crt" }
      when: cockpit_dir.stat.exists
      notify: Restart Cockpit
      # Creates symlinks for Cockpit if directory exists

    - name: Check if Cockpit is installed
      stat:
        path: /usr/lib/systemd/system/cockpit.service
      register: cockpit_service
      # Checks if Cockpit is installed on target server

    - name: Set ownership and permissions for Cockpit service (if installed)
      file:
        path: "{{ item }}"
        owner: root
        group: root
        mode: "{{ '0400' if 'key' in item else '0644' }}"
      loop:
        - "{{ key_path }}"
        - "{{ cert_path }}"
      when: cockpit_service.stat.exists
      notify: Restart Cockpit
      # Sets permissions for Cockpit if installed

  handlers:
    - name: Restart Cockpit
      service:
        name: cockpit
        state: restarted
      when: cockpit_service.stat.exists
      # Restarts Cockpit only if installed
